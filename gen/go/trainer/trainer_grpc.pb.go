// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: trainer/trainer.proto

package trainerv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Trainer_ListForGym_FullMethodName           = "/trainer.Trainer/ListForGym"
	Trainer_AvailableBookingList_FullMethodName = "/trainer.Trainer/AvailableBookingList"
	Trainer_CurrentBookingList_FullMethodName   = "/trainer.Trainer/CurrentBookingList"
	Trainer_Booking_FullMethodName              = "/trainer.Trainer/Booking"
	Trainer_UnBooking_FullMethodName            = "/trainer.Trainer/UnBooking"
)

// TrainerClient is the client API for Trainer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainerClient interface {
	ListForGym(ctx context.Context, in *ListForGymRequest, opts ...grpc.CallOption) (*ListForGymResponse, error)
	AvailableBookingList(ctx context.Context, in *AvailableBookingListRequest, opts ...grpc.CallOption) (*AvailableBookingListResponse, error)
	CurrentBookingList(ctx context.Context, in *CurrentBookingListRequest, opts ...grpc.CallOption) (*CurrentBookingListResponse, error)
	Booking(ctx context.Context, in *BookingRequest, opts ...grpc.CallOption) (*BookingResponse, error)
	UnBooking(ctx context.Context, in *UnBookingRequest, opts ...grpc.CallOption) (*UnBookingResponse, error)
}

type trainerClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainerClient(cc grpc.ClientConnInterface) TrainerClient {
	return &trainerClient{cc}
}

func (c *trainerClient) ListForGym(ctx context.Context, in *ListForGymRequest, opts ...grpc.CallOption) (*ListForGymResponse, error) {
	out := new(ListForGymResponse)
	err := c.cc.Invoke(ctx, Trainer_ListForGym_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainerClient) AvailableBookingList(ctx context.Context, in *AvailableBookingListRequest, opts ...grpc.CallOption) (*AvailableBookingListResponse, error) {
	out := new(AvailableBookingListResponse)
	err := c.cc.Invoke(ctx, Trainer_AvailableBookingList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainerClient) CurrentBookingList(ctx context.Context, in *CurrentBookingListRequest, opts ...grpc.CallOption) (*CurrentBookingListResponse, error) {
	out := new(CurrentBookingListResponse)
	err := c.cc.Invoke(ctx, Trainer_CurrentBookingList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainerClient) Booking(ctx context.Context, in *BookingRequest, opts ...grpc.CallOption) (*BookingResponse, error) {
	out := new(BookingResponse)
	err := c.cc.Invoke(ctx, Trainer_Booking_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainerClient) UnBooking(ctx context.Context, in *UnBookingRequest, opts ...grpc.CallOption) (*UnBookingResponse, error) {
	out := new(UnBookingResponse)
	err := c.cc.Invoke(ctx, Trainer_UnBooking_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainerServer is the server API for Trainer service.
// All implementations must embed UnimplementedTrainerServer
// for forward compatibility
type TrainerServer interface {
	ListForGym(context.Context, *ListForGymRequest) (*ListForGymResponse, error)
	AvailableBookingList(context.Context, *AvailableBookingListRequest) (*AvailableBookingListResponse, error)
	CurrentBookingList(context.Context, *CurrentBookingListRequest) (*CurrentBookingListResponse, error)
	Booking(context.Context, *BookingRequest) (*BookingResponse, error)
	UnBooking(context.Context, *UnBookingRequest) (*UnBookingResponse, error)
	mustEmbedUnimplementedTrainerServer()
}

// UnimplementedTrainerServer must be embedded to have forward compatible implementations.
type UnimplementedTrainerServer struct {
}

func (UnimplementedTrainerServer) ListForGym(context.Context, *ListForGymRequest) (*ListForGymResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListForGym not implemented")
}
func (UnimplementedTrainerServer) AvailableBookingList(context.Context, *AvailableBookingListRequest) (*AvailableBookingListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableBookingList not implemented")
}
func (UnimplementedTrainerServer) CurrentBookingList(context.Context, *CurrentBookingListRequest) (*CurrentBookingListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentBookingList not implemented")
}
func (UnimplementedTrainerServer) Booking(context.Context, *BookingRequest) (*BookingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Booking not implemented")
}
func (UnimplementedTrainerServer) UnBooking(context.Context, *UnBookingRequest) (*UnBookingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnBooking not implemented")
}
func (UnimplementedTrainerServer) mustEmbedUnimplementedTrainerServer() {}

// UnsafeTrainerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainerServer will
// result in compilation errors.
type UnsafeTrainerServer interface {
	mustEmbedUnimplementedTrainerServer()
}

func RegisterTrainerServer(s grpc.ServiceRegistrar, srv TrainerServer) {
	s.RegisterService(&Trainer_ServiceDesc, srv)
}

func _Trainer_ListForGym_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListForGymRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainerServer).ListForGym(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trainer_ListForGym_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainerServer).ListForGym(ctx, req.(*ListForGymRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trainer_AvailableBookingList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvailableBookingListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainerServer).AvailableBookingList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trainer_AvailableBookingList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainerServer).AvailableBookingList(ctx, req.(*AvailableBookingListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trainer_CurrentBookingList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrentBookingListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainerServer).CurrentBookingList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trainer_CurrentBookingList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainerServer).CurrentBookingList(ctx, req.(*CurrentBookingListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trainer_Booking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainerServer).Booking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trainer_Booking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainerServer).Booking(ctx, req.(*BookingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trainer_UnBooking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnBookingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainerServer).UnBooking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trainer_UnBooking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainerServer).UnBooking(ctx, req.(*UnBookingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Trainer_ServiceDesc is the grpc.ServiceDesc for Trainer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trainer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "trainer.Trainer",
	HandlerType: (*TrainerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListForGym",
			Handler:    _Trainer_ListForGym_Handler,
		},
		{
			MethodName: "AvailableBookingList",
			Handler:    _Trainer_AvailableBookingList_Handler,
		},
		{
			MethodName: "CurrentBookingList",
			Handler:    _Trainer_CurrentBookingList_Handler,
		},
		{
			MethodName: "Booking",
			Handler:    _Trainer_Booking_Handler,
		},
		{
			MethodName: "UnBooking",
			Handler:    _Trainer_UnBooking_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trainer/trainer.proto",
}
